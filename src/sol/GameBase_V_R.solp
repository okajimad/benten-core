pragma solidity ^0.4.0;
import "./CoinCashier.sol";
import "./IRegulation.sol";
import "./IGame.sol";
import "./ResultAnnouncement_R#RESULT_SIZE.sol";
import "./MajorityVote_R#RESULT_SIZE.sol";

contract GameBase_V ##VOTE_SIZE _R ##RESULT_SIZE	 is BettingTarget_V ##VOTE_SIZE , IGame {   

	string internal _title;
	string internal _className;
	address[] internal _addresses; //better list
	uint internal _ownerSupply;

	ResultAnnouncement_R ##RESULT_SIZE	 internal _resultSource;
	IRegulation internal _regulation;
	uint internal _openTime;
	uint internal _lockTime;
	bool internal _closed;
	// cancel option
	bool internal _allowCancel;
	bool internal _cancelled;     //flag of cancelling game by owner
	uint internal _totalBettings; //current total betting volume

	//results: these are set in close() function
	uint internal _totalRefunds;
	uint internal _cashierFee;
	uint internal _ownerRefund;
	uint[] internal _refunds; //corresponding to _addresses

	event Entried(address indexed user, VOTE_TYPE content, uint volume);
	event Closed(RESULT_TYPE truth, uint userCount, uint totalBetting, uint totalRefund);
	event Cancelled(uint userCount, uint totalBetting, uint totalRefund);

	constructor(string title, address cashier, address result_src, address regulation, address owner, uint open_time, uint lock_time, bool allow_cancel) public {
		_title = title;
		_owner = owner;
		_cashier = CoinCashier(cashier);
		_resultSource = ResultAnnouncement_R ##RESULT_SIZE(result_src);
		_regulation = IRegulation(regulation);
		_openTime = open_time;
		_lockTime = lock_time;
		_allowCancel = allow_cancel;
	}

	function title() public view returns(string) {
		return _title;
	}
	function className() public view returns(string) {
		return _className;
	}
	function openTime() public view returns(uint) {
		return _openTime;
	}
	function lockTime() public view returns(uint) {
	    return  _lockTime;
	}
	function isClosed() public view returns(bool) {
		return _closed;
	}
	function cancelAllowed() public view returns(bool) {
		return _allowCancel;
	}
	function cancelled() public view returns(bool) {
		return _cancelled;
	}
	function betAcceptable() public view returns(bool) {
		return _openTime <= getNow() && getNow() <= _lockTime;
	}
	function ownerSupplyBody(uint coin) internal {
		_ownerSupply += coin;
	}
	function regulation() public view returns(address) {
		return _regulation;
	}
	function resultSource() public view returns(address) {
		return _resultSource;
	}
	function getOwnerSupply() public view onlyOwner returns(uint) {
		return _ownerSupply;
	}

	function totalBettings() public view returns(uint) {
		return _totalBettings;
	}
	function totalRefunds() public view returns(uint) {
		require(_closed);
		return _totalRefunds;
	}
	function refundTuple() public view returns(address[] a, uint[] v, uint cf, uint ow) {
		require(_closed);
		return (_addresses, _refunds, _cashierFee, _ownerRefund);
	}

	//Description of each candidate can be embedded in contract storage
	struct CandidateDescription {
		VOTE_TYPE content;
		string description;
	}
	CandidateDescription[] internal _descriptions;
	function setDescription(VOTE_TYPE content, string new_description) public  {
		require(_openTime > getNow());
		
		for(uint i=0; i<_descriptions.length; i++) {
			CandidateDescription storage e = _descriptions[i];
			if(e.content == content) {
				revert(); //overwriting is not permitted
			}
		}
		CandidateDescription memory ne = CandidateDescription(content, new_description);
		_descriptions.push(ne);
	}
	function setDescription_Multiple(VOTE_TYPE content1, string new_description1, VOTE_TYPE content2, string new_description2, VOTE_TYPE content3, string new_description3, VOTE_TYPE content4, string new_description4, VOTE_TYPE content5, string new_description5) public  {
		if(bytes(new_description1).length > 0) setDescription(content1, new_description1);
		if(bytes(new_description2).length > 0) setDescription(content2, new_description2);
		if(bytes(new_description3).length > 0) setDescription(content3, new_description3);
		if(bytes(new_description4).length > 0) setDescription(content4, new_description4);
		if(bytes(new_description5).length > 0) setDescription(content5, new_description5);
	}
	
	function getDescription(VOTE_TYPE content) public view returns(string) {
		for(uint i=0; i<_descriptions.length; i++) {
			CandidateDescription storage e = _descriptions[i];
			if(e.content == content) {
				return e.description;
			}
		}
		return "";
	}
	function getDescriptionCount() public view returns(uint) {
		return _descriptions.length;
	}

	// getDescriptionList() style function is not allowed since 'string[]' cannot be used as return type of function!

}
