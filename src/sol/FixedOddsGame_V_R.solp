pragma solidity ^0.4.0;
import "./CoinCashier.sol";
import "./IRegulation.sol";
import "./GameBase_V#VOTE_SIZE_R#RESULT_SIZE.sol";

contract FixedOddsGame_V ##VOTE_SIZE _R ##RESULT_SIZE	 is GameBase_V ##VOTE_SIZE _R ##RESULT_SIZE  {
	struct Entry {
		VOTE_TYPE content;
		uint volume; 
	}
	mapping (address => Entry[]) internal _entries;
	Entry[] internal _bettings;


	constructor(string title, address cashier, address voting, address regulation, address owner, uint open_time, uint close_time, bool allow_cancel) public GameBase_V ##VOTE_SIZE _R ##RESULT_SIZE(title, cashier, voting, regulation, owner, open_time, close_time, allow_cancel) {
	}

	function betBody(address from, VOTE_TYPE content, uint coin) internal {
		if(!betAcceptable()) 
			ERROR_CASE("betting not acceptable")

		entry(from, content, coin);
	}

	function entry(address from, VOTE_TYPE content, uint volume) private {
		Entry[] storage e = _entries[from];
		bool new_entry = e.length==0;
		if(new_entry) _addresses.push(from);
		e.push(Entry(content, volume));

		uint32 index = findOrCreate(content);
		_bettings[index].volume += volume;
		_totalBettings += volume;

		emit Entried(msg.sender, content, volume);
	}

	function bettingOf() public view returns(VOTE_TYPE[], uint[]) {
		Entry[] storage e = _entries[msg.sender];
		VOTE_TYPE[] memory b = new VOTE_TYPE[](e.length);
		uint[] memory v = new uint[](e.length);
		for(uint i=0; i<e.length; i++) {
			b[i] = e[i].content;
			v[i] = e[i].volume;
		}
		return (b, v);
	}

	function currentBettingList() public view returns(VOTE_TYPE[], uint[], uint[] ) {
		VOTE_TYPE[] memory candidates = new VOTE_TYPE[](_bettings.length);
		uint[] memory counts = new uint[](_bettings.length);
		uint[] memory volumes = new uint[](_bettings.length);
		for(uint i=0; i<_bettings.length; i++) {
			Entry storage e = _bettings[i];
			candidates[i] = e.content;
			volumes[i] = e.volume;
			counts[i] += 1;
		}
		return (candidates, counts, volumes);
	}
/*
	function currentBettingAndEstimatedRefundList() public view returns(VOTE_TYPE[], uint[], uint[] ) {
		VOTE_TYPE[] memory candidates = new VOTE_TYPE[](_bettings.length);
		uint[] memory volumes = new uint[](_bettings.length);
		uint[] memory refunds = new uint[](_bettings.length);
		for(uint i=0; i<_bettings.length; i++) {
			Entry storage e = _bettings[i];
			candidates[i] = e.content;
			volumes[i] = e.volume;
			refunds[i] = this.estimateTotalRefund(e.content);
		}
		return (candidates, volumes, refunds);
	}
*/
	function findOrCreate(VOTE_TYPE content) internal returns(uint32) {
		for(uint i=0; i<_bettings.length; i++) {
			if(content == _bettings[i].content)
				return uint32(i);
		}
		_bettings.push(Entry(content, 0));
		return uint32(_bettings.length-1);
	}
	function findEntryIndex(VOTE_TYPE content) internal view returns(uint32) {
		for(uint i=0; i<_bettings.length; i++) {
			if(content == _bettings[i].content)
				return uint32(i);
		}
		return 0xFFFFFFFF;
	}

	//abstract
	function estimateOdds(VOTE_TYPE vote, RESULT_TYPE truth) public view returns(int);

	function estimateTotalRefund(RESULT_TYPE truth) public view returns(uint) {
		uint total_refund = 0;
		for(uint i=0; i<_bettings.length; i++) {
			Entry storage e = _bettings[i];
			if(e.volume!=0) {
				int t = estimateOdds(e.content, truth);
				total_refund += permilMul(e.volume, uint(t));
			}
		}
		return total_refund;
	}

	//Close Voting
	function close() public onlyOwnerOrCashier {
		if(!_resultSource.isClosed())
			ERROR_CASE("voting address is not closed")
		if(_cancelled)
			ERROR_CASE("game is already cancelled")
		if(_closed)
			ERROR_CASE("game is already closed")

		uint i;
		address a;
		RESULT_TYPE truth = _resultSource.truth(); //get correct answer
		_totalRefunds = estimateTotalRefund(truth);

		if(_totalRefunds > _totalBettings + _ownerSupply) 
			ERROR_CASE("owner supply is insufficient")

		CashierBase cashier = CashierBase(_cashier);

		for(i=0; i<_addresses.length; i++) {
			a = _addresses[i];
			Entry[] storage e = _entries[a];
			uint refund = 0;
			for(uint j=0; j<e.length; j++) {
				Entry storage ee = e[j];
				int t = estimateOdds(ee.content, truth);
				if(t == -1)
					refund += ee.volume; // confiscated game
				else
					refund += permilMul(ee.volume, uint(t));
			}
			if(refund>0)
				_cashier.transferCoin(a, refund);
			_refunds.push(refund);
		}
		
		//remaining coin go to the owner of this game
		uint base_profit = _totalBettings + _ownerSupply - _totalRefunds;
		_cashierFee = IRegulation(_regulation).calcCashierFee(_totalBettings);
		if(_cashierFee > base_profit) {
			_cashierFee = base_profit;
			_ownerRefund = 0;
		}
		else
			_ownerRefund = base_profit - _cashierFee;

		_cashier.transferCoin(getOwner(), _ownerRefund);
		_cashier.transferCoin(cashier.getOwner(), _cashierFee);
		_closed = true;

		emit Closed(truth, _addresses.length, _totalBettings, _totalRefunds);
	}

	function cancelGame() public onlyOwner {
		if(_closed)
			ERROR_CASE("game is already closed")
		if(_cancelled)
			ERROR_CASE("game is already cancelled")
		if(!_allowCancel)
			ERROR_CASE("cancel is not allowed")

		_totalRefunds = 0;
		for(uint i=0; i<_addresses.length; i++) {
			address a = _addresses[i];
			Entry[] storage e = _entries[a];
			uint refund = 0;
			for(uint j=0; j<e.length; j++) {
				refund += e[j].volume;
			}
			if(refund>0)
				_cashier.transferCoin(a, refund);
			_refunds.push(refund);
			_totalRefunds += refund;
		}
		
		if(_ownerSupply>0)
			_cashier.transferCoin(this.getOwner(), _ownerSupply);
		_cancelled = true;
		_closed = true;

		emit Cancelled(_addresses.length, _totalBettings, _totalRefunds);
	}



}
