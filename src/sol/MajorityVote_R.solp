pragma solidity ^0.4.0;

import "./ICoinCashier.sol";
import "./ResultAnnouncement_R#RESULT_SIZE.sol";

contract MajorityVote_R ##RESULT_SIZE	is ResultAnnouncement_R ##RESULT_SIZE {
	struct Vote {
		uint32 index;
		uint volume;
	}
	mapping (address => Vote) private _voters;
	address[] private _addresses;

	uint private _votingFee;
	uint private _totalVote;
	RESULT_TYPE[] private _candidates;

	//filled at the time of voting lock
	uint32 private _truthIndex;
	uint32 constant UNDECIDED = 0xFFFFFFFF;
	uint[] private _refundList;
	uint private _finalVoteVolume;
	uint private _refundFraction;

	uint private _timeExtensionOnReversal;
	uint private _lockTimeExtensionCount;

	event Voted(address indexed voter, RESULT_TYPE content, uint volume);
	event MajorityReversal(address indexed voter, RESULT_TYPE content, uint volume);
	event NoMajority();

	constructor(address cashier, address regulation, address owner, uint open_time, uint lock_time) public ResultAnnouncement_R ##RESULT_SIZE (cashier, regulation, owner, open_time, lock_time) {
		_truthIndex = UNDECIDED;
		_timeExtensionOnReversal = 30 minutes;
		_version = "MajorityVote.0";
	}

	//owner is changable if current owner is null.
	//this feature is used by contract deployment by regulation or web server
	function activate(address cashier, address regulation, address newOwner, uint open_time, uint lock_time) public {
		if(_owner!=address(0))
			ERROR_CASE("current owner is not null")
		_cashier = ICoinCashier(cashier);
		_regulation = IRegulation(regulation);
		_openTime = open_time;
		_lockTime = lock_time;
		_closed = false;
		_truthIndex = UNDECIDED;
		_timeExtensionOnReversal = 30 minutes;

		_owner = newOwner; //set new owner
	}

	function ownerSupplyBody(uint coin) internal {
		_votingFee += coin;
	}
	function votingFee() public view returns(uint) {
		return _votingFee;
	}
	function lockTimeExtensionCount() public view returns(uint) {
		return _lockTimeExtensionCount;
	}
	function betBody(address from, RESULT_TYPE content, uint coin) internal {
		vote(from, content, coin);
	}

	function vote(address from, RESULT_TYPE content, uint volume) private {
		if(from!=getOwner() && !voteAcceptable()) //voting owner can vote any time to protect from malicious voting
			ERROR_CASE("voting is not acceptable")
		if(_closed)
			ERROR_CASE("voting is already closed")
		
		if(_totalVote + volume < _totalVote)
			ERROR_CASE("overflow")

		uint32 index = findOrCreate(content);
		if(_totalVote!=0) {
			uint32 major_index = currentMajorIndex();
			uint major_total = currentVotingOf(major_index);
			// if all votings are unlimited, voting fee cannot pay even gas of voting.
			// to reserve voters profit, additional votes for 99% majority is rejected.
			if(index==major_index && majorityRatioPermil() > 990)
				ERROR_CASE("Existing Voter Profit Protect")

			// in case of reversals ( it may be malicious! ), the lock time is extended automatically.
			// the other justice voters get a chance of steal the malicious votes.
			if(index!=major_index && currentVotingOf(index)+volume >= major_total) {
				emit MajorityReversal(from, content, volume);
				_lockTime += _timeExtensionOnReversal;
				_lockTimeExtensionCount++;
			}

		}

		_totalVote += volume;
		Vote storage ch = _voters[from];
		bool new_voter = ch.volume==0;
		// in case of multiple votes, the last vote content is valid. volume is total votes.
		ch.index = index;
		//uint current_volume = ch.volume;
		ch.volume = ch.volume + volume;
			
		if(new_voter)
			_addresses.push(from); 
		emit Voted(from, content, volume);
	}

	function findOrCreate(RESULT_TYPE content) private returns(uint32) {
		for(uint i=0; i<_candidates.length; i++) {
			RESULT_TYPE ch = _candidates[i];
			if(content==ch)
				return uint32(i);
		}
		_candidates.push(content);
		return uint32(_candidates.length-1);
	}
	function currentVotingOf(uint32 index) private view returns(uint) {
		uint[] memory volumes;
		(, volumes) = currentVotingList();
		return volumes[index];
	}
	function currentMajorIndex() private view returns(uint32) {
		uint[] memory volumes;
		(, volumes) = currentVotingList();
		uint32 major_index = 0;
		uint major_volume = 0;
		for(uint i=0; i<volumes.length; i++) {
			uint v = volumes[i];
			if(v > major_volume) {
				major_volume = v;
				major_index = uint32(i);
			}
		}
		return major_index;
	}
	function majorityRatioPermil() public view returns(uint) {
		if(_totalVote==0) return 0;

		uint32 major_index = currentMajorIndex();
		uint major_total = currentVotingOf(major_index);
		return major_total * 1000 / _totalVote;
	}

	function currentVotingList() public view returns(RESULT_TYPE[], uint[] ) {
		uint[] memory volumes = new uint[](_candidates.length);
		for(uint i=0; i<_addresses.length; i++) {
			address a = _addresses[i];
			Vote storage v = _voters[a];
			volumes[v.index] += v.volume;
		}
		return (_candidates, volumes);
	}
	// bytes[] is not allowed by solidity compiler. then use fixed size instead.
	function candidateList() public view returns(RESULT_TYPE[] memory) {
		return _candidates;
	}

	//Close Voting
	function close() public onlyOwnerOrCashier {
		if(getNow() < _lockTime)
			ERROR_CASE("current time is before voting close time")
		if(_closed)
			ERROR_CASE("voting is already closed")
		if(majorityRatioPermil() < 900) {
			emit NoMajority();
			_lockTime += _timeExtensionOnReversal;
			_lockTimeExtensionCount++;
			return;
		}
		

		uint32 max_index = 0;
		uint max = 0;
		uint total = 0;
		uint i;
		address a;

		uint[] memory volumes = new uint[](_candidates.length);
		for(i=0; i<_addresses.length; i++) {
			a = _addresses[i];
			volumes[i] += _voters[a].volume;
		}

		for(i=0; i<volumes.length; i++) {
			if(max < volumes[i]) {
				max = volumes[i];
				max_index = uint32(i);
			}
			total += volumes[i];
		}
		_finalVoteVolume = total;
		_truthIndex = max_index;

		uint fv = _finalVoteVolume + _votingFee;
		uint cv = volumes[_truthIndex];
		uint fraction = 0;
		for(i=0; i<_addresses.length; i++) {
			a = _addresses[i];
			uint reward = 0;
			if(_voters[a].index == _truthIndex) {
				reward = fv * _voters[a].volume / cv;
				fraction += (fv * _voters[a].volume) % cv;
			}
			_refundList.push(reward);
		}

		_refundFraction = fraction;
		_cashier.multiTransferCoin(_addresses, _refundList);
		_cashier.transferCoin(getOwner(), _refundFraction);
		_closed = true;

		emit Closed(this.truth());
	}

	function voterCount() public view returns(uint) {
		return _addresses.length;
	}
	function refundTuple() public view returns(address[] a, uint[] v, uint f) {
		if(_truthIndex==UNDECIDED) revert();
		return (_addresses, _refundList, _refundFraction);
	}
	function truth() public view returns(RESULT_TYPE) {
		if(_truthIndex==UNDECIDED)
			return -1;
		else
			return _candidates[_truthIndex];
	}



}
